function [rtn] = rates_params(varargin)
% Generate rate map parameters.
%
% This function has two modes of working: 1) call a UI, where the user
% specifies the parameters, 2) generate default parameters, with the option
% to define specific parameters on the input line.
%
% Mode 1:       [rtn] = rates_params();
%
% Mode 2:       [rtn] = rates_params('default');
%                                 or
%               [rtn] = rates_params('param_name', param_value, ... );
%
% Param names are the struct field names (see below). Also see below for 
% possible field values.
%
% params struct (rtn) is:
%
%       'mode'                <'rate'>, 'pos', 'spike', 'speed'
%       'space'               <'place'> or 'dir'
%       'bin'                 power of 2 integer <8>
%       'smooth'              odd integer <5>
%       'adaptive_smooth'     <[]>
%       'bin_dir'             <6>                
%       'smooth_dir'          <5>
%       'crop'                <[]>, [x y] or [a b x y]
%       'trial_index'         <[]> or numerical index, limited between 1 and n trials. Too save time, we can choose to only make maps for some trials. Not on GUI, need to use command line call.
%       'abs_space'           flag <1>
%       'crop_to_filt'        flag <0>
%       'alg'                 'pxd' or <'pd'>
%       'trans_active'        flag <0>
%       'trans_target'        integer index into data.trials <1>
%       'trans_reg_size'      flag <1>
%       'filt_time'           <[]> or [min max]
%       'filt_1stHalf'        flag <0>    \_  Shortcut to filter 1st or 2nd half of the trial.
%       'filt_2ndHalf'        flag <0>    /   Cannot both be set to 1.
%       'filt_speed'          <[]> or [min max]
%       'filt_dir'            <[]> or [min max]
%       'filt_x'              <[]> or [min max]
%       'filt_y'              <[]> or [min max]
%       'filt_index'          <[]> or arbitrary index into position bins.
%       'min_dwell'           <[]> or a value in seconds. Bins with value < min_dwell, in the UNSMOOTHED pos map, are marked NaN before making rate map.
%       'tag'                 general user defined string, <''>
%
% Also note that prms.filt_time can be size (n_trial,2) - allows
% different times per trial, although this can't be generated by the UI.

% ui figure was made with GUIDE, and stored in rates_uiparams.fig
% don't use standard GUIDE m-file, though. Use this instead.
% All uicontrol callbacks in the figure are 'rates_uiparams_redraw(tag)',
% with the exception of the 'OK' button, which is 'uiresume'

%%% Define default structure %%%
rtn(1).bin = 8;                 
rtn(1).smooth = 5;
rtn(1).adaptive_smooth = [];
rtn(1).bin_dir = 6;                 
rtn(1).smooth_dir = 5;
rtn(1).crop = [];        
rtn(1).abs_space = 1;          
rtn(1).crop_to_filt = 0;
rtn(1).space = 'place';
rtn(1).alg = 'pd';   
rtn(1).mode = 'rate';
rtn(1).trial_index = [];
rtn(1).trans_active = 0;
rtn(1).trans_target = 1;
rtn(1).trans_reg_size = 1;
rtn(1).filt_time = [];
rtn(1).filt_1stHalf = 0;
rtn(1).filt_2ndHalf = 0;
rtn(1).filt_speed = [];
rtn(1).filt_dir = [];
rtn(1).filt_x = [];
rtn(1).filt_y = [];
rtn(1).filt_index=[];
rtn(1).min_dwell=[];
rtn(1).tag = '';

if ~isempty(varargin)
    %%% Manually defined parameters %%%
    if strcmp(varargin{1}, 'default')
        return
    else
        for ii=1:2:length(varargin)
            rtn.(varargin{ii}) = varargin{ii+1};
        end
    end
 elseif isempty(varargin)
    %%% UI defined parameters %%%
    SD = gss;
    % Open figure %
    h_fig = openfig('rates_params.fig', 'new');
    if ~isempty(SD)
        figPos = get(h_fig,'position');
        set(h_fig, 'position', [(SD.screenChar(3:4)-figPos(3:4))./2 figPos(3:4)]);
    end
    H = guihandles(h_fig);
    %%% List of trials for transformations %%
    if isempty(SD)                          % No SCAn running (called functionally) - no transform list.
        trial_str = {''};
    elseif length(SD.selData)==1            % One dataset selected - list trial names
        data = evalin('base', SD.selData{1});
        [trial_str{1:length(data.trials)}] = deal(data.trials.trialname);
    else                                    % Multiple datasets - list is trial 1; trial 2 etc. Length is min of N trials in datasets.
        for ii=1:length(SD.selData)
            tmp = evalin('base', SD.selData{ii});
            n(ii) = length(tmp.trials);
        end
        for ii=1:min(n)
            trial_str{ii} = ['Trial ', num2str(ii)];
        end
        set(H.trans_target, 'fontangle', 'italic');
    end
    set(H.trans_target, 'string', trial_str);
    %%% Set all callbacks to @fRedraw (Necessary for fRedraw to be 'visible' when declared) %% 
    f = fieldnames(H);
    for ii=1:length(f)
        if ~strcmp(get(H.(f{ii}),'tag'),'figure')   % No callbacks for figures
            set(H.(f{ii}), 'callback', @fRedraw);
        end
    end
    set(H.ok_button, 'callback', 'uiresume');
    set(H.cancel_button, 'callback', 'uiresume');
   
    %%%%%%%%%%%%%%%%%%% Wait for OK press %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    uiwait(h_fig);
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    if strcmp(get(gco,'tag'),'cancel_button')
        rtn=[];   delete(h_fig);   return;   
    end
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    %%% OK button pressed. Get uicontrol values, roll up into rtn structure %%%
    % Sampling Params %
    rtn.bin = str2double(get(H.samp_bin, 'string'));
    rtn.smooth = str2double(get(H.samp_smooth, 'string'));
    if ~isempty(get(H.samp_ad_smooth,'string'))
        rtn.adaptive_smooth=str2double(get(H.samp_ad_smooth,'string'));
    end
    rtn.bin_dir = str2double(get(H.samp_bin_dir, 'string'));
    rtn.smooth_dir = str2double(get(H.samp_smooth_dir, 'string'));
    % Crop Params %
    if get(H.crop_active, 'value')
        if get(H.crop_radio_fc, 'value')
            tmp1 = get(H.crop_x_fc, 'string');
            tmp2 = get(H.crop_y_fc, 'string');
            tmp3 = get(H.crop_w_fc, 'string');
            tmp4 = get(H.crop_h_fc, 'string');
            rtn.crop = str2num([tmp1, ' ', tmp2, ' ', tmp3, ' ', tmp4]);
            rtn.abs_space = 1;
        elseif get(H.crop_radio_ce, 'value')
            tmp1 = get(H.crop_w_ce, 'string');
            tmp2 = get(H.crop_h_ce, 'string');
            rtn.crop = str2num([tmp1 ' ' tmp2]);
            rtn.crop_to_filt = get(H.crop_filt_ce, 'value');
            rtn.abs_space = 0;
        end    
    else
        rtn.crop = [];
        rtn.abs_space = 1;
        rtn.crop_to_filt = 0;
    end
    % Map type params %
    if get(H.type_alg_pd, 'value');
        rtn.alg = 'pd';
    elseif get(H.type_alg_pxd, 'value');
        rtn.alg = 'pxd';
    elseif get(H.type_alg_dh, 'value');
        rtn.alg = 'dh';
    end
    if get(H.type_space_place, 'value') || get(H.type_alg_pxd, 'value');    % When alg is 'pxd', space='place', then create space='dir' params later, by hand.
        rtn.space = 'place';
    elseif get(H.type_space_dir, 'value');
        rtn.space = 'dir';
    end
    if get(H.type_mode_rate, 'value') || get(H.type_alg_pxd, 'value');  % mode='rate' always for PxD.
        rtn.mode = 'rate';
    elseif get(H.type_mode_pos, 'value');
        rtn.mode = 'pos';
    elseif get(H.type_mode_spike, 'value');
        rtn.mode = 'spike';   
    elseif get(H.type_mode_speed, 'value');
        rtn.mode = 'speed';   
    end
    % Transformations %
    rtn.trans_active = get(H.trans_active, 'value');
    rtn.trans_target = get(H.trans_target, 'value');
    rtn.trans_reg_size = get(H.trans_reg_size, 'value');
    %%% Filter Parameters %%%
    %%% This section also creates 'long' params structs for when there %%%
    %%% is a map series. Needs to go last.                             %%%
    % Defaults%
    rtn.filt_time = [];
    rtn.filt_speed = [];
    rtn.filt_dir = [];
    rtn.filt_x = [];
    rtn.filt_y = [];
    % Values? %
    if get(H.filt_time_chk, 'value')
        tmp1 = str2num(get(H.filt_time_min, 'string'));
        tmp2 = str2num(get(H.filt_time_max, 'string'));
        for ii=1:str2num(get(H.filt_time_series, 'string'))
            rtn(ii) = rtn(1);
            rtn(ii).filt_time = [tmp1, tmp2];
            d = tmp2-tmp1;
            tmp1 = tmp2;
            tmp2 = tmp1+d;
        end
    end
    if get(H.filt_speed_chk, 'value')
        tmp1 = str2num(get(H.filt_speed_min, 'string'));
        tmp2 = str2num(get(H.filt_speed_max, 'string'));
        for ii=1:str2num(get(H.filt_speed_series, 'string'))
            rtn(ii) = rtn(1);
            rtn(ii).filt_speed = [tmp1, tmp2];
            d = tmp2-tmp1;
            tmp1 = tmp2;
            tmp2 = tmp1+d;
        end
    end
    if get(H.filt_dir_chk, 'value')
        tmp1 = str2num(get(H.filt_dir_min, 'string'));
        tmp2 = str2num(get(H.filt_dir_max, 'string'));
        for ii=1:str2num(get(H.filt_dir_series, 'string'))
            rtn(ii) = rtn(1);
            rtn(ii).filt_dir = [tmp1, tmp2];
            d = tmp2-tmp1;
            tmp1 = tmp2;
            tmp2 = tmp1+d;
        end
    end
    if get(H.filt_x_chk, 'value')
        tmp1 = str2num(get(H.filt_x_min, 'string'));
        tmp2 = str2num(get(H.filt_x_max, 'string'));
        for ii=1:str2num(get(H.filt_x_series, 'string'))
            rtn(ii) = rtn(1);
            rtn(ii).filt_x = [tmp1, tmp2];
            d = tmp2-tmp1;
            tmp1 = tmp2;
            tmp2 = tmp1+d;
        end
    end
    if get(H.filt_y_chk, 'value')
        tmp1 = str2num(get(H.filt_y_min, 'string'));
        tmp2 = str2num(get(H.filt_y_max, 'string'));
        for ii=1:str2num(get(H.filt_y_series, 'string'))
            rtn(ii) = rtn(1);
            rtn(ii).filt_y = [tmp1, tmp2];
            d = tmp2-tmp1;
            tmp1 = tmp2;
            tmp2 = tmp1+d;
        end
    end
    % Delete the figure %
    delete(h_fig);
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [] = fRedraw(hObj,eventData)
%%% Update rates_uiparams figure, depending on user actions.
H = guihandles(hObj);
tag = get(hObj,'tag');   frame_tag = tag(1:4);    % Frame identifier first 4 characters.
switch frame_tag
case 'crop'
    %%% Crop frame %%%
    % some useful handle groups %
    h_fixed = [H.crop_w_fc, H.crop_h_fc, H.crop_x_fc, H.crop_y_fc];
    h_cen = [H.crop_w_ce, H.crop_h_ce, H.crop_filt_ce, H.crop_filttext_ce];
    h_crop_all = [H.crop_gentext H.crop_square H.crop_radio_fc H.crop_radio_ce h_fixed h_cen, H.crop_filt_ce, H.crop_filttext_ce];
    % Is activated? %
    if strcmp(tag, 'crop_active');
        if get(H.crop_active, 'value');
            set(h_crop_all, 'enable', 'on');
            if get(H.crop_radio_fc, 'value')
                set(h_cen, 'enable', 'off');
            elseif get(H.crop_radio_ce, 'value')
                set(h_fixed, 'enable', 'off');
            end
        else
            set(h_crop_all, 'enable', 'off');
        end
    end
    % Fixed or Centred? %
    if strcmp(tag, 'crop_radio_fc');
        set(H.crop_radio_ce, 'value', 0);
        set(H.crop_radio_fc, 'value', 1);
        set(h_cen, 'enable', 'off');
        set(h_fixed, 'enable', 'on');
    elseif strcmp(tag, 'crop_radio_ce');
        set(H.crop_radio_ce, 'value', 1);
        set(H.crop_radio_fc, 'value', 0);
        set(h_cen, 'enable', 'on');
        set(h_fixed, 'enable', 'off');            
    end
    % Set Square Crops %
    if get(H.crop_square, 'value') & ( strcmp(tag(1:6), 'crop_h') | strcmp(tag(1:6), 'crop_w') )
        % get correct box tag %
        tag_to_set = tag;
        if strcmp(tag(6), 'h')
            tag_to_set(6) = 'w';
        else
            tag_to_set(6) = 'h';
        end
        % Set value %
        val_to_set = get(getfield(H, tag), 'string');
        set(getfield(H, tag_to_set), 'string', val_to_set); 
    end
case 'filt'    
    %%% Data Filters Frame %%%
    % Only need to worry about filter activation checkboxes %
    if strcmp(tag(end-2:end), 'chk')
        % Get handles of relevant uicontrol set %
        switch tag(6:end)
        case 'time_chk'
            h_filt = [H.filt_time_min, H.filt_time_max, H.filt_time_series];
        case 'speed_chk'
            h_filt = [H.filt_speed_min, H.filt_speed_max, H.filt_speed_series];
        case 'dir_chk'
            h_filt = [H.filt_dir_min, H.filt_dir_max, H.filt_dir_series];
        case 'x_chk'
            h_filt = [H.filt_x_min, H.filt_x_max, H.filt_x_series];
        case 'y_chk'
            h_filt = [H.filt_y_min, H.filt_y_max, H.filt_y_series];
            
        end
        % turn on or off? %
        if get(getfield(H, tag), 'value')
            enable_val = 'on';
        else 
            enable_val = 'off';
        end
        % Set %
        set(h_filt, 'enable', enable_val);
    end       
case 'type'    
    %%% Map Type Frame %%%
    % Space Group %
    if strcmp(tag, 'type_space_place');
        set(H.type_space_place, 'value', 1);
        set(H.type_space_dir, 'value', 0);
        % Some other defaults to reset for place maps %
%         set(H.samp_bin, 'string', '8');   % NOTE, 01/10/09. No longer needed, as seperate place and dir bin boxes.
        set(H.crop_active, 'enable', 'on');
    elseif strcmp(tag, 'type_space_dir');
        set(H.type_space_place, 'value', 0);
        set(H.type_space_dir, 'value', 1);
        % Some other defaults to reset for dir maps %
%         set(H.samp_bin, 'string', '6');  % NOTE, 01/10/09. No longer needed, as seperate place and dir bin boxes.
        set(H.crop_active, 'enable', 'off');
    end
    % Algorithm group %
    if strcmp(tag, 'type_alg_pd');
        set(H.type_alg_pd, 'value', 1);
        set([H.type_alg_pxd H.type_alg_dh], 'value', 0);
        set([H.type_space_place H.type_space_dir H.type_mode_rate H.type_mode_pos H.type_mode_spike], 'enable', 'on');
    elseif strcmp(tag, 'type_alg_pxd');
        set(H.type_alg_pxd, 'value', 1);
        set([H.type_alg_pd H.type_alg_dh], 'value', 0);
        set(H.type_mode_rate, 'value', 1);                      %
        set([H.type_mode_pos H.type_mode_spike], 'value', 0);   % PxD maps must be rate.
        set([H.type_space_place H.type_space_dir], 'enable', 'off');
        set([H.type_mode_rate H.type_mode_pos H.type_mode_spike], 'enable', 'inactive'); % All these selections automatic for PxD
    elseif strcmp(tag, 'type_alg_dh');
        set(H.type_alg_dh, 'value', 1);
        set([H.type_alg_pxd H.type_alg_pd], 'value', 0);
        set([H.type_space_place H.type_space_dir], 'enable', 'on');
        set(H.type_mode_rate, 'value', 1);                                               %
        set([H.type_mode_pos H.type_mode_spike], 'value', 0);                            % Dist hypo maps must be rate.
        set([H.type_mode_rate H.type_mode_pos H.type_mode_spike], 'enable', 'inactive'); % 
    end
    % Mode group %
    if strcmp(tag, 'type_mode_rate');
        set(H.type_mode_rate, 'value', 1);
        set(H.type_mode_pos, 'value', 0);
        set(H.type_mode_spike, 'value', 0);
        set(H.type_mode_speed, 'value', 0);
    elseif strcmp(tag, 'type_mode_pos');
        set(H.type_mode_rate, 'value', 0);
        set(H.type_mode_pos, 'value', 1);
        set(H.type_mode_spike, 'value', 0);
        set(H.type_mode_speed, 'value', 0);
    elseif strcmp(tag, 'type_mode_spike');
        set(H.type_mode_rate, 'value', 0);
        set(H.type_mode_pos, 'value', 0);
        set(H.type_mode_spike, 'value', 1);
        set(H.type_mode_speed, 'value', 0);
    elseif strcmp(tag, 'type_mode_speed');
        set(H.type_mode_rate, 'value', 0);
        set(H.type_mode_pos, 'value', 0);
        set(H.type_mode_spike, 'value', 0);
        set(H.type_mode_speed, 'value', 1);
    end      
case 'tran'
    % Transform %
    h_trans = [H.trans_target, H.trans_reg_size, H.trans_text];
    if get(H.trans_active, 'value') == 1
        set(h_trans, 'enable', 'on');
    else
        set(h_trans, 'enable', 'off');
    end    
end